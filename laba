using System;

namespace ConsoleApplication1
{


	//Событие представляет собой автоматическое уведомление о том, что произошло некоторое действие. 
	//События действуют по следующему принципу: объект, проявляющий интерес к событию, 
	//регистрирует обработчик этого события. Когда же событие происходит, вызываются все 
	//зарегистрированные обработчики этого события. Обработчики событий обычно представлены делегатами.

	//События являются членами класса и объявляются с помощью ключевого слова event. Чаще всего 
	//для этой цели используется следующая форма:

	//event делегат_события имя_события;
	//где делегат_события обозначает имя делегата, используемого для поддержки события,
	//а имя_события — конкретный объект объявляемого события.

	//События основаны на делегатах и предоставляют им механизм публикации/подписки. В каркасе 
	//.NET события присутствуют повсюду. В приложениях Windows класс Button поддерживает событие Click. 
	//Этот тип события является делегатом. Метод-обработчик, вызываемый с событием Click, должен быть определен
	//с параметрами, заданными в типе делегата.

	//Как и делегаты, события поддерживают групповую адресацию. 
	//Это дает возможность нескольким объектам реагировать на уведомление о событии.


	//Событие, это не что иное, как ситуация, при возникновении которой, 
    //произойдет действие или несколько действий. Говоря языком программного 
    //моделирования, Событие — это именованный делегат, при вызове которого, 
    //будут запущены все подписавшиеся на момент вызова события методы заданной сигнатуры.



	class Povysit_I //Это класс, реагирующий на событие (счет равен 71) записью строки в консоли.
	{
		public void Message()
		{
			//Не забудьте using System 
			//для вывода в консольном приложении
			Console.WriteLine("Пора действовать, ведь уже 71!");
		}
	}

	class Shtraf_II
	{
		public void Message()
		{
			Console.WriteLine("Точно, уже 71!");
		}
	}

	class Director  //Это класс - в котором производится счет.
	{
		public delegate void MethodContainer();

		//Событие OnCount c типом делегата MethodContainer.
		public event MethodContainer onCount;

		public void Count()
		{
			for (int i = 0; i < 100; i++)
			{
				if (i == 71)
				{
                    onCount();
				}
			}
		}
	}










	class Program
	{

       delegate int Operation(int x, int y);
		static void Main(string[] args)
		{
			Director Counter = new Director();
			Povysit_I Povysit1 = new Povysit_I();
            Shtraf_II Shtraf2 = new Shtraf_II();

			//Подписались на событие
			Counter.onCount += Povysit1.Message;
			Counter.onCount +=Shtraf2.Message;

			//Запустили счетчик
			Counter.Count();


			//лямбда выражения 

			//Лямбда-выражения представляют упрощенную запись анонимных методов. 
			//Лямбда-выражения позволяют создать емкие лаконичные методы, которые 
			//могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.

			//Ламбда - выражения имеют следующий синтаксис: слева от лямбда - оператора => определяется список параметров,
			//а справа блок выражений, использующий эти параметры: (список_параметров) => выражение.


			//Здесь код (x, y) => x + y; представляет лямбда-выражение, где x и y - это параметры, а x + y - выражение. 
            //При этом нам не надо указывать тип параметров, а при возвращении результата не надо использовать оператор return.

			//При этом надо учитывать, что каждый параметр в лямбда-выражении неявно преобразуется в
            //соответствующий параметр делегата, поэтому типы параметров должны быть одинаковыми.Кроме того,
            //количество параметров должно быть таким же, как и у делегата. И возвращаемое значение 
            //лямбда-выражений должно быть тем же, что и у делегата.То есть в данном случае использованное
            //лямбда - выражение соответствует делегату Operation как по типу возвращаемого значения, так 
            //и по типу и количеству параметров.

			Operation operation = (x, y) => x + y;
			Console.WriteLine(operation(10, 20));       // 30
			Console.WriteLine(operation(40, 20));       // 60

			//Делегаты Action, Predicate и Func

           //В .NET есть несколько встроенных делегатов, которые используются в различных ситуациях.
            //И наиболее используемыми, с которыми часто приходится сталкиваться, являются Action, Predicate и Func.
          //Action
            //Делегат Action является обобщенным, принимает параметры и возвращает значение void:
           // public delegate void Action<T>(T obj)
          //  Данный делегат имеет ряд перегруженных версий.Каждая версия принимает разное число параметров:
            //от Action<in T1> до Action<in T1, in T2,....in T16>. Таким образом можно передать до 16 значений в метод.
           // Как правило, этот делегат передается в качестве параметра метода и предусматривает вызов
            //определенных действий в ответ на произошедшие действия.


			//делегат action

			Action<int, int> op;
			op = Add;
			Operation2(10, 6, op);
			op = Substract;
			Operation2(10, 6, op);


			//Predicate

            //Делегат Predicate<T>, как правило, используется для сравнения, 
            //сопоставления некоторого объекта T определенному условию.В качестве 
            //выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено:

            Predicate<int> isPositive = delegate (int x) { return x > 0; };

			Console.WriteLine(isPositive(20));
			Console.WriteLine(isPositive(-20));
			//В данном случае возвращается true или false в зависимости от того, больше нуля число или нет.




			//Func

			//Еще одним распространенным делегатом является Func.Он возвращает результат 
			//действия и может принимать параметры. Он также имеет различные формы: от
			//Func<out T>(), где T -тип возвращаемого значения, до Func <in T1, in T2,...in T16, 
			//out TResult > (), то есть может принимать до 16 параметров.
			Func<int, int> retFunc = Factorial;
			int n1 = GetInt(6, retFunc);
			Console.WriteLine(n1);  // 720

			int n2 = GetInt(6, x => x * x);
			Console.WriteLine(n2); // 36


		}


		//делегат action 




		static void Operation2(int x1, int x2, Action<int, int> op)
		{
			if (x1 > x2)
				op(x1, x2);
		}

		static void Add(int x1, int x2)
		{
			Console.WriteLine("Сумма чисел: " + (x1 + x2));
		}

		static void Substract(int x1, int x2)
		{
			Console.WriteLine("Разность чисел: " + (x1 - x2));
		}




		//делегат func
		//Метод GetInt() в качестве параметра принимает делегат Func<int, int>, то есть ссылку на метод, 
        //который принимает число int и возвращает также значение int.

		//При первом вызове метода GetInt() ему передается ссылка на метод вычисления факториала.
        //Во втором случае передается лямбда-выражение x => x * x, то есть опять же выражение, 
        //которое принимает параметр int x и возвращает результат x * x.

		static int GetInt(int x1, Func<int, int> retF)
		{
			int result = 0;
			if (x1 > 0)
				result = retF(x1);
			return result;
		}
		static int Factorial(int x)
		{
			int result = 1;
			for (int i = 1; i <= x; i++)
			{
				result *= i;
			}
			return result;
		}

	}
}
